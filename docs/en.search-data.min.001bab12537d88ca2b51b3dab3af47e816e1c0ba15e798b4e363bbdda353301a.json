[{"id":0,"href":"/what_is_ipfs/","title":"IPFSとは何か？","section":"IPFS入門","content":"IPFSとは何か？ #  IPFS（InterPlanetary File System）は Protocol Labsにより開発が進めれられているP2Pネットワーク上で動作するハイパーメディアプロトコルとその実装です。\n現在のインターネットで主要なプロトコルであるHTTP（Hyper Text Transfer Protocol）を補完または置換するプロトコルとして位置付けられ、コンテンツ指向型1のプロトコルであるところに大きな特徴があります。\nHTTPはロケーション指向型プロトコル #  例えば現在のインターネットで情報にアクセスする場合https://hogehoge.com/aaa/hello.htmlといったURLを指定してアクセスします。このURLの意味するところは、「hogehoge.comというホストサーバにあるaaaというディレクトリの中のhello.htmlというファイル」ということであり、つまりは取得したい情報がある「場所」（サーバの名前、ディレクトリの名前、ファイル名）を指定しているものです。このように欲しい情報が存在する「場所」を指定して情報にアクセスする方法は「ロケーション指向」と呼ばれ、HTTPはロケーション指向のプロトコルです2。\nロケーション指向の弊害 #  このようなロケーション指向での情報へのアクセスは直感的にわかりやすいものです。しかし多くの弊害もあります。まず一つは「情報へのアクセス可能性を保つために管理者に大きな責任（負担）が生じる」というものです。例えば上記例でのhello.html内の情報へのアクセスは「hogehoge.com」のホストサーバの管理状態に依存してしまうことがわかります。hello.html内の情報に全ての人が恒常的にアクセスすることを可能にするために、サーバ管理者には、\n 24時間365日サーバーを安定稼働させなければならない。 アクセスの数が増えた場合にも遅延なく応答するためのインフラを準備しないといけない。 hello.html内の情報を改ざんされないように、不正アクセスを防ぐための対策を継続しないといけない。 hello.htmlをサーバから削除しない、またはファイル名を変更しないようにしないといけない。  といった責務が生じ、その負担は小さくありません。\nこのような責任（負担）の裏返しで、サーバ管理者に情報へのアクセスに関する全権力が集中するという弊害もあります。サーバ管理者は\n 情報へのアクセスを自由に禁止／制限できる。 情報へのアクセスに自由に課金できる。 情報を自由に削除できる。 情報を自由に改ざんできる。  というように、情報へのアクセスに関する全ての権力がサーバ管理者に集中してしまいます。\nもちろん、情報の所有者がその情報へのアクセスを管理できることは、多くの場合で有意義なものです。しかし一方で、インターネットが発明されて以降、徐々にあらゆる情報はごく少数の巨大サービスに集中し始めています。例えば個人間の社会的繋がりや日々の行動などが facebookに莫大なデータ量が蓄積され管理されています。facebookは私的企業であり、彼らのサービス規定に則りアクセス制限を自由にかけることが可能です。さらにはサービス規定自体もfacebook自身が決めることができるのです。よってユーザーは、自分自身の生み出した様々なデータがfacebook社によって改ざんやアクセス制限、不正利用などされない「だろう」と信じて預けるほかにありません。しかし実際にはそのような信用は裏切られ、アメリカ大統領選挙の際にfacebook社が不正に約8,000万人分のユーザーデータをトランプ陣営側のデータ分析会社に提供する 事件が発生しています。\nまた情報アクセスへの制限は、サービス（サーバ）管理者だけでなく例えば国家によってもなされる場合があります。2017年4月29日トルコ政府はトルコ国内で全ての言語のWikipediaへのアクセスを遮断しました。当初は 制限に至る理由も公表されることなく3、突如禁止され、現在もアクセスが禁止され続けています。インターネットでの情報アクセスがロケーション指向であるため、Wikipediaのサーバへのアクセスを遮断するだけで容易に市民の情報へのアクセスが制限することが可能になるのです。\nインターネットが発明されて以来数十年の間、ロケーション指向の情報アクセスはうまく動作してきたように見えます。しかしインターネットの発展と共に、上記のようにロケーション指向による弊害やリスクといったものが少しずつ顕在化してきています。\nIPFSはコンテンツ指向型プロトコル #  このような問題を根本的に解決するためにIPFSではコンテンツ指向型のプロトコルを採用しています。\n例えばあなたが書籍、例えば 養老孟司の「バカの壁」を読みたいと思ったとき、その書籍が読めればそれがどこから入手したものかを気にすることはほとんどありません。近所の本屋さんで買っても、Amazonで買っても、図書館から借りても同じ内容を読むことができます。\nインターネット上の情報も同様です。同一の内容であればどのサーバ上から取得したか？どの名前のファイルから取得したかなどという入手先はほとんどの場合で重要ではありません。そのためその情報の「場所」ではなく、「こういう内容の情報」というコンテンツの内容自体を直接指定して情報にアクセスする仕組みを考えることができます。これが「コンテンツ指向」になります。\nコンテンツ指向プロトコルの仕組みは古くから研究されており様々な実装方法が提案されています。その中でもIPFSでは SHAなどの暗号ハッシュ関数を利用してコンテンツのハッシュ値を求め、それをそのコンテンツのIDとして利用する方法を採用しています。ハッシュ関数により得られるハッシュ値は、同じデータであれば必ず同じハッシュ値が得られる一方、少しでも異なるデータからはまったく異なるハッシュ値が得られる特徴があります。そのためこのハッシュ値をキーにアクセスするIPFSには、ロケーション指向であるHTTPプロトコルでは得られない以下のようなメリットが生まれます。\n耐障害性 #  IPFSではコンテンツのハッシュ値を指定し、そのコンテンツが存在する場所（サーバ\u0008等）を指定しません。そのため、たとえオリジナルのサーバが何らかの原因でダウンしていても、同じハッシュ値（＝コンテンツ）のデータを持っているどこか他の場所から同じ情報を取得することが可能になります。（読みたい本がある書店で売り切れていたら他の書店で買い求めるのと同様の動作です。前述のとおり内容が同じであればどの書店から購入しようがユーザーは気にしないのです。）\n負荷分散 #  コンテンツの場所を指定しないIPFSでは、同じコンテンツを複数のサーバから取得できる場合、より近いサーバから取得することになります。一つのサーバーに負荷が集中することを防ぐことが可能になります。\n耐検閲性 #  先のトルコの例に見るようにロケーション指向ネットワークでは、その情報のある場所（サーバ）へのアクセスを遮断するだけで検閲が可能でした。一方、コンテンツ指向ネットワークでは同じコンテンツは無数のサーバで保持されることが可能であり、どこかのサーバがアクセスを遮断されても、代理の他のどこかの別のサーバから同一の情報が取得可能になり、検閲を難しくします。\n耐改ざん性 #  データのハッシュ値をキーにデータにアクセスするということはデータの改ざんを不可能にします。データを取得した人はアクセスしたデータのIDであるハッシュ値と、そのコンテンツから得られるハッシュ値を比較することで容易にコンテンツの正当性を検証することができるからです。\nFilecoin #  以上のようにHTTPに比べて様々な利点があるIPFSですが、１つ問題が残っています。それはIPFSのP2Pネットワークのノードがコンテンツを保持する動機となるもの（インセンティブ）がないことです。\nHTTPの世界でビジネスを行う事業者自身が自身のビジネスのためにデータを保持してきていました。例えばFacebookはSNSサービスを充実させてユーザーを確保し収入を得るということをインセンティブに、膨大なテキストや画像さらには動画コンテンツデータを自身のサーバに保存します。しかしIPFSではP2Pネットワークがコンテンツをシェアしあいながら保存する形式を行っており、コンテンツを保持する者とそのコンテンツをもとにビジネスを行う者が必ずしも一致しません。そのためIPFSに参加しているノードにデータを保持するインセンティブが存在しないのです。\nそこで生み出されたのが Filecoinです。Filecoinは一種の仮想通貨です。FilecoinはProof-of-Spacetimeという仕組みによりIPFS上にストレージを提供した時間や量に応じて仮想通貨Filecoinが与えられることでIPFS参加ノードがコンテンツを保持するインセンティブが加わることになるのです。\n普及が始まったIPFS #  このように従来のHTTPプロトコルにはないメリットを有したIPFSは、以下のように実際のサービスでの利用が続々と始まっています。\n 個人用のホームページのホスティングの草分けであるNeoCitiesがそのホスティングにIPFSを採用（ 公式ブログ）。 ブロックチェーンプロトコルEthereumがそのメインサイト ethereum.orgをIPFSでホスティングすることを創始者のVitalikが 発表。 Webブラウザ「Brave」がIPFSをサポート。”ipfs://” で始まるURIを指定することでIPFSコンテンツにアクセスが可能に（ 公式アナウンス）。  また、Filecoinについても着実に開発が進められ2020年10月に本番ネットワーク(Mainnet）が 稼働し始めました。\nまたP2Pの分散型ファイルシステムという特徴から、IPFSはEthereumなどのブロックチェーン技術との相性がよく、それらを組み合わせて構築される様々なサービスが 開発され始めています。\n次章よりIPFSやFilecoinに実際に触れながら、それがどのようなものか?どのように利用できるのか?をより詳細に見て行きましょう。\n脚注 #    同様のことを示す用語として、「コンテンツアドレス」や「情報指向」とも呼ばれることがありますが、本書ではコンテンツ指向と名称を統一します。 \u0026#x21a9;\u0026#xfe0e;\n 従来のファイルシステムも同様です。例えばWindowsPC上で特定のファイルを取得する場合は「¥¥C:Documents¥hello.txt」のように指定されますが、これはCドライブにあるDocumentsというフォルダの中のhello.txtという「場所」を指定していることになります。 \u0026#x21a9;\u0026#xfe0e;\n 後に、トルコ政府は「トルコ政府がシリア内戦を支援しているとしてトルコを批判する2つの英語のページが削除されなかったこと」との理由を公表している。 \u0026#x21a9;\u0026#xfe0e;\n   "},{"id":1,"href":"/faq/","title":"FAQ","section":"IPFS入門","content":"FAQ #  Q: IPFSリポジトリを再度初期化するには？ #  IPFSのノードのリポジトリ情報は全て${HOME}/.ipfsディレクトリ内に保存されています（ここで${HOME}はユーザーのHOMEディレクトリです）。そのため、本ディレクトリとその内容を全て削除し、再度ipfs initコマンドを実行することで再初期化が可能になります。以下、ubuntu環境でのコマンド例です。\n※ 事前にipfs daemonでipfsが動いている状態の場合は事前にkillしておく必要があります。\n$ cd ~ #HOMEディレクトリへの移動 $ ls .ipfs blocks config datastore datastore_spec keystore version $ rm -rf .ipfs $ ipfs init initializing IPFS node at /home/ubuntu/.ipfs generating 2048-bit RSA keypair...done peer identity: QmTfTzbaoo4K98VsfG7efr3A4FErsEXAc5utcWjnsCaiz1 to get started, enter: ipfs cat /ipfs/QmS4ustL54uo8FzR9455qaxZwuMiUhyvMcX9Ba8nUH4uVv/readme "},{"id":2,"href":"/install_ipfs/","title":"IPFSのインストール","section":"IPFS入門","content":"IPFSのインストール #  先の章でIPFSはP2P型のファイルシステムであることを説明しました。IPFSを利用するためにIPFSクライアントをインストールする必要があります。ここではGo言語で実装されたクライアントであるgo-ipfsを利用します。\ngo-ipfsのインストール #  go-ipfsのインストールは非常に容易です。ここでは、Ubuntu 18.04 LTS環境での例を示しますが他OSでも同様です。基本的には go-ipfsのダウンロードサイトよりビルド済みバイナリパッケージをダウンロードして解凍したのち、実行モジュールをPATHが通っているディレクトリに配置するスクリプトを動かすだけです。下記にコマンド例を示します。\n$ wget https://dist.ipfs.io/go-ipfs/v0.5.0/go-ipfs_v0.5.0_linux-amd64.tar.gz #URLは、環境やバージョンにより適宜変更してください。 $ tar xvzf go-ipfs_v0.5.0_linux-amd64.tar.gz $ cd go-ipfs/ $ sudo ./install.sh ここで、下記のようにipfs versionのコマンドを実行しバージョン情報が表示されれば問題なくインストールされています。\n$ ipfs version ipfs version 0.5.0 ■Tips: go-ipfsのアップデート #  新しいバージョンのgo-ipfsにアップデートをする場合も、上記のインストール手順を新しいバージョンのモジュールで行うことでアップデート可能です。ただし、go-ipfsをデーモンとして起動（後述）している場合はそれを停止してから行ってください。\n​\nIPFSリポジトリの初期化 #  go-ipfsのインストールを終えたら、IPFSのP2Pネットワークに参加するために下記のコマンドを実行してローカルのIPFSリポジトリを初期化します。\n$ ipfs init initializing IPFS node at /home/ubuntu/.ipfs generating 2048-bit RSA keypair...done peer identity: QmP5PY85F8XjH5gF67qXLCmU3BxyAW7NdFJ1h8Vpk8zu7s to get started, enter: ipfs cat /ipfs/QmQPeNsJPyVWPFDVHb77w8G42Fvo15z4bG2X8D2GhfbSXc/readme 実行結果に示されるようにユーザーのhomeディレクトリ直下に.ipfsディレクトリが生成される。このディレクトリがIPFSのリポジトリとなります。\n実行結果の最後に示されたipfs cat ...のコマンドをコンソール上で実行してみましょう。詳細は後述しますがipfs catはIPFSネットワーク上に保存されているファイルの内容を取得するコマンドで、ここではreadmeファイルの内容を取得しています。\n$ ipfs cat /ipfs/QmQPeNsJPyVWPFDVHb77w8G42Fvo15z4bG2X8D2GhfbSXc/readme Hello and Welcome to IPFS! ██╗██████╗ ███████╗███████╗ ██║██╔══██╗██╔════╝██╔════╝ ██║██████╔╝█████╗ ███████╗ ██║██╔═══╝ ██╔══╝ ╚════██║ ██║██║ ██║ ███████║ ╚═╝╚═╝ ╚═╝ ╚══════╝ If you\u0026#39;re seeing this, you have successfully installed IPFS and are now interfacing with the ipfs merkledag! ------------------------------------------------------- | Warning: | | This is alpha software. Use at your own discretion! | | Much is missing or lacking polish. There are bugs. | | Not yet secure. Read the security notes for more. | ------------------------------------------------------- Check out some of the other files in this directory: ./about ./help ./quick-start \u0026lt;-- usage examples ./readme \u0026lt;-- this file ./security-notes 先の章で紹介したとおり、IPFSはコンテンツアドレス型の仕組みを取り入れており、通常のファイルシステムとはファイルの取扱い方法が大きく異なっています。次節より実際にgo-ipfsを操作しIPFS上でファイルがどのように扱われるのかを見ていきましょう。\n"},{"id":3,"href":"/adding_files/","title":"IPFSへのファイルの追加","section":"IPFS入門","content":"ファイルの追加 #  既存の多くのファイルシステムやインターネットの仕組みは、ある情報を取得する場合にその情報のある「場所（サーバやディレクトリ）」を指定して、そこにある情報を取得する方式をとっています（ロケーション指向）。一方IPFSでは、取得したい情報がどこにあるかは意識せず、直接コンテンツ自体に紐づく識別子（アドレス）を元に情報にアクセスとする「コンテンツ指向」型の仕組みを採用しています。本節ではgo-ipfsを操作しながら、IPFSではファイルやその内容（=コンテンツ）がどのように扱われアクセスされるのかを具体的に見ていきます。\nリポジトリにコンテンツを追加する #  下記のコマンドを実行して、\u0026ldquo;hello world\u0026quot;という内容のtest1.txtという名前のファイルを作成してください。\n$ echo \u0026#34;hello world\u0026#34; \u0026gt; test1.txt $ cat test1.txt hello world 次に下記のコマンドを実行します。\n$ ipfs add test1.txt added QmT78zSuBmuS4z925WZfrqQ1qHaJ56DQaTfyMUF7F8ff5o test1.txt ここでipfs addは指定したファイルの内容を「IPFSオブジェクト」としてIPFSのリポジトリに登録するコマンドです。結果で表示されたQmT78zSu....は今回のファイルの内容である「hello world」をハッシュ化した値であり、これがこのコンテンツの識別子（アドレス）になります。このコンテンツを参照するにはipfs cat \u0026lt;アドレス\u0026gt;のコマンドを実行します。そこで今回登録したアドレスの内容を参照して見ましょう。結果として「hello world」が表示されるはずです。\n$ ipfs cat QmT78zSuBmuS4z925WZfrqQ1qHaJ56DQaTfyMUF7F8ff5o hello world 同じコンテンツなら一意のアドレス #  次に、全く同じ内容のもう一つのファイルtest2.txtというファイルを作成してIPFSに追加します。\n$ echo \u0026#34;hello world\u0026#34; \u0026gt; test2.txt $ cat test2.txt hello world $ ipfs add test2.txt added QmT78zSuBmuS4z925WZfrqQ1qHaJ56DQaTfyMUF7F8ff5o test2.txt するとtest1.txtをipfs addした時と全く同じハッシュ値QmT78zSu....が表示されることに気づいたはずです。そのためこれを参照するのもtest1.txtの時と全く同じアドレスQmT78zSu....を指定してアクセスすることになります。\n$ ipfs cat QmT78zSuBmuS4z925WZfrqQ1qHaJ56DQaTfyMUF7F8ff5o hello world このようにIPFSにおいて、異なるファイルでipfs addしてもその内容が同一であれば、インプット元のファイルの違いは全く区別されません。これはすなわちipfs addで追加するものは「ファイル」ではなく「コンテンツ自身」つまり今回の例では「hello world」というコンテンツ自体を追加していることを意味しています。またそのコンテンツを参照する場合も、これまでのファイルシステムやインターネットとは異なり、test1.txtやtest2.txtのそのコンテンツがある場所（今回の場合はファイル）を指定するのではなく、QmT78zSu....というコンテンツ自体の識別子（アドレス）を示すハッシュ値を指定します。これがコンテンツ指向の思想です。\n下のコードのようにファイルではなくパイプを利用して直接「hello world」をaddすることも可能であり、またその参照ハッシュ値もファイルでの追加時と同一であることからも、ipfs addで追加するものは「ファイル」ではなく「コンテンツ自身」であることが実感できるでしょう。\n$ echo \u0026#34;hello world\u0026#34; | ipfs add added QmT78zSuBmuS4z925WZfrqQ1qHaJ56DQaTfyMUF7F8ff5o QmT78zSuBmuS4z925WZfrqQ1qHaJ56DQaTfyMUF7F8ff5o $ ipfs cat QmT78zSuBmuS4z925WZfrqQ1qHaJ56DQaTfyMUF7F8ff5o hello world   巨大なコンテンツは分割されて保存される #  IPFSでは、コンテンツのサイズが256KBを超える場合、256KB以下の部品（チャンク）に分割して管理されます。これは主にP2Pのネットワーク上でコンテンツの転送を効率化する目的で行われています。複数の細切れのコンテンツに分割することで、一つのノードから全てを取得するのではなく、コンテンツのパーツを複数のノードから同時に取得してそれらを一つに組み合わせることで、より素早くコンテンツを取得することが可能になります。\n実際に大きなファイルがチャンクに分割されて管理する様子を見ていきます。ここでは猫の画像 cat.jpg 1 を使います。\n$ wget https://github.com/a-mitani/ipfs-primer/raw/master/static/images/cat.jpg $ ll cat.jpg # ファイルサイズ確認 約610KB \u0026gt; 256KB -rw-rw-r-- 1 ubuntu ubuntu 624861 Mar 19 11:13 cat.jpg $ ipfs add cat.jpg # cat.jpgをリポジトリに登録 added QmZZrDCuCV5A3WsxbbC6UCtrHtNs2eVyfJwF7JcJJoJGwV cat.jpg これで、QmZZrDCu...のアドレスにcat.jpgのコンテンツのIPFSオブジェクトが登録されました。ここでこのオブジェクトを少し詳しく見ていきましょう。\n$ ipfs ls QmZZrDCuCV5A3WsxbbC6UCtrHtNs2eVyfJwF7JcJJoJGwV QmT97cgDGaFBYJYZfAA3WFa9h6sFhKNkPTPH81S9x3JY3o 262158 QmNaE7A7VszmF2TaBKmkU9Z4HQo347wiXb9ZGch4rPt4aG 262158 Qmd6h47LMqE2oGoFy15aoDcWjSGpj3KzNYuBvkgAaSEarU 100587 ここでipfs lsコマンドは指定されたアドレスのIPFSオブジェクトからリンクされているIPFSオブジェクトのアドレスとそのサイズを列挙するコマンドです。QmZZrDCu...のオブジェクトから３つのオブジェクトが参照されているのが分かります。そしてこれらの３つのオブジェクトが元のcat.jpgを分割したものになります。\nipfs catを利用することでipfsは３つの分割されたファイルを組み合わせて、元ファイル（cat.jpg）と同一のcat_output.jpgが出力できます。\n$ ipfs cat QmZZrDCuCV5A3WsxbbC6UCtrHtNs2eVyfJwF7JcJJoJGwV \u0026gt; cat_output.jpg $ ll cat*jpg #元ファイルと出力ファイルでのファイルの比較 → 同じ -rw-rw-r-- 1 ubuntu ubuntu 624861 Mar 19 11:13 cat.jpg -rw-rw-r-- 1 ubuntu ubuntu 624861 Mar 19 11:52 cat_output.jpg $ cmp cat.jpg cat_output.jpg #念のため２つのファイルをバイナリ比較。何も出力されず一致することがわかる。 ディレクトリ #  これまでIPFSではコンテンツ自身のハッシュ値がアドレスとなり、それをキーにコンテンツにアクセスする旨を書いてきました。一方でIPFSはさらにコンテンツへの参照を持つディレクトリのオブジェクトの作成が可能です。ディレクトリからコンテンツを指すリンクを辿って構造的にコンテンツにアクセスすることを可能にしています。先ほど作成したtest1.txtとtest2.txtファイルを利用して実際の動きを見ていきましょう。\nまずは以下のようにテスト用のディレクトリtestdirを作成しその中にtest1.txtとtest2.txtを格納します。\n$ cat test1.txt hello world $ cat test2.txt hello world $ mkdir testdir $ mv test*.txt testdir/ ## test1.txtとtest2.txtをtestdir内に移動 $ ls testdir/ test1.txt test2.txt そしてディレクトリ自体をipfs addしてみます。ここで-rオプションは指定したディレクトリtestdir以下の全てのディレクトリやファイルを再帰的にリポジトリに追加していくオプションです。\n$ ipfs add -r testdir added QmT78zSuBmuS4z925WZfrqQ1qHaJ56DQaTfyMUF7F8ff5o testdir/test1.txt added QmT78zSuBmuS4z925WZfrqQ1qHaJ56DQaTfyMUF7F8ff5o testdir/test2.txt added QmWpxMfLZcDVeMcBJXoZbqpaeXdzXBxoBScYSSb8ctzu8W testdir ここで出力の１行目と２行目はtestdir以下に配置したそれぞれのコンテンツがリポジトリに追加されたことを示すものです。先述と同じくコンテンツ自身を示すためアドレスは共にQmT78zSu...となります。またこのアドレスは先ほどのディレクトリ以下に配置していない場合にaddした場合とも同じであることに注意してください。繰り返しですがこれは、アドレスはコンテンツに一意に決定され、そのコンテンツがどの場所（ディレクトリ）やどのファイル内に存在するかはコンテンツ指向のIPFSのアドレスには関係が無いからです。\n3行目の出力はディレクトリがリポジトリにaddされたことを示す出力です。IPFSにおいてはディレクトリも一種のIPFSオブジェクトとして扱われます。そしてそのオブジェクトの内容は、他のIPFSオブジェクトへの名前付きリンクになっています。ディレクトリ内に含まれるリンク情報をipfs lsで見てみましょう。\n$ ipfs ls QmWpxMfLZcDVeMcBJXoZbqpaeXdzXBxoBScYSSb8ctzu8W QmT78zSuBmuS4z925WZfrqQ1qHaJ56DQaTfyMUF7F8ff5o 20 test1.txt QmT78zSuBmuS4z925WZfrqQ1qHaJ56DQaTfyMUF7F8ff5o 20 test2.txt この出力は、今回登録したディレクトリにはtest1.txtとtest2.txtという「名前付きのリンク」が含まれて、それらは同じQmT78zSu...を参照していることを示しています。\nまた、コンテンツはディレクトリから「リンク名」を指定して辿るかたちで参照することが可能です。\n$ ipfs cat QmWpxMfLZcDVeMcBJXoZbqpaeXdzXBxoBScYSSb8ctzu8W/test1.txt #ディレクトリオブジェクトからリンク名を辿ってアクセス hello world ロケーション指向のインターネット等とは異なり、ここでtest1.txtを指定しているのはファイル名を指定しているのではなく、あくまでディレクトリのQmT78zSu...のコンテンツを指す「リンク名」を指定していることに注意してください。\nまたディレクトリを作成しても依然、以下のように「hello world」のコンテンツにはそのハッシュ値QmT78zSu...により直接アクセスすることも可能であることは、コンテンツ指向の重要な特徴です。\n$ ipfs cat QmT78zSuBmuS4z925WZfrqQ1qHaJ56DQaTfyMUF7F8ff5o #直接アクセス hello world   $ ipfs object patch add-link QmXMg3DMLH7ouewbPMnvHRziyxq49XkN1UdMbSALmDRv1c \"hogehoge\" QmT78zSuBmuS4z925WZfrqQ1qHaJ56DQaTfyMUF7F8ff5o #コマンドを実行すると新たなディレクトリが生成される QmVhuCdEBoxtXJCwjMUz6oupmL212tRaocEYuuJ5QeKWWt $ ipfs ls QmVhuCdEBoxtXJCwjMUz6oupmL212tRaocEYuuJ5QeKWWt #リンク情報を見るとhogehogeが追加されている。 QmT78zSuBmuS4z925WZfrqQ1qHaJ56DQaTfyMUF7F8ff5o 20 hogehoge QmT78zSuBmuS4z925WZfrqQ1qHaJ56DQaTfyMUF7F8ff5o 20 test1.txt ``` ``` $ # リンクの削除コマンド → ipfs object patch rm-link   $ ipfs object patch rm-link QmVhuCdEBoxtXJCwjMUz6oupmL212tRaocEYuuJ5QeKWWt test1.txt #コマンドを実行すると新たなディレクトリが生成される QmRe4beQkVRLUgrBj6cYymCeNJvLuqM23epWsVCNZXRij2 $ ipfs ls QmRe4beQkVRLUgrBj6cYymCeNJvLuqM23epWsVCNZXRij2 #リンク情報を見るとhogehogeのみが残っている。 QmT78zSuBmuS4z925WZfrqQ1qHaJ56DQaTfyMUF7F8ff5o 20 hogehoge $ ipfs cat QmRe4beQkVRLUgrBj6cYymCeNJvLuqM23epWsVCNZXRij2/hogehoge #新たなリンク名でアクセスすると「hello world」が表示される。 hello world ``` ディレクトリのリンク情報を変更ることは即ちディレクトリのコンテンツを変更することであり、結果そのハッシュ値も変わるります。そのためディレクトリの編集を行うとディレクトリのアドレス自体が変わることに注意してください。 -- IPFSオブジェクト #  これまでipfs addで、コンテンツやディレクトリをIPFSオブジェクトとして追加しそれにアクセスする方法を見てきました。IPFSではチャンク化されたものを含むコンテンツやディレクトリなどすべて区別なく「IPFSオブジェクト」として扱われます。ところでIPFSオブジェクトの実体はどのようなモノでしょうか？結論からいうとIPFSオブジェクトの実体は、\n IPFSオブジェクトへのリンク（IPFSリンク）の配列（Links） データ（Data）  の２つの要素から構成される構造体です。\n実際にIPFSオブジェクトをシリアライズ化して表示する ipfs object getコマンドを利用して、これまで作成したIPFSオブジェクトを見てみましょう。\nまずは、ディレクトリとして作成されたIPFSオブジェクトQmXMg3DM...を調べてみます。\n$ ipfs object get QmWpxMfLZcDVeMcBJXoZbqpaeXdzXBxoBScYSSb8ctzu8W { \u0026#34;Links\u0026#34;: [ { \u0026#34;Name\u0026#34;:\u0026#34;test1.txt\u0026#34;, \u0026#34;Hash\u0026#34;:\u0026#34;QmT78zSuBmuS4z925WZfrqQ1qHaJ56DQaTfyMUF7F8ff5o\u0026#34;, \u0026#34;Size\u0026#34;:20 }, { \u0026#34;Name\u0026#34;:\u0026#34;test2.txt\u0026#34;, \u0026#34;Hash\u0026#34;:\u0026#34;QmT78zSuBmuS4z925WZfrqQ1qHaJ56DQaTfyMUF7F8ff5o\u0026#34;, \u0026#34;Size\u0026#34;:20 } ], \u0026#34;Data\u0026#34;:\u0026#34;\\u0008\\u0001\u0026#34; } 出力（見易さのため整形してます）から確かにIPFSオブジェクトが\u0026quot;Links\u0026quot;と\u0026quot;Data\u0026quot;の２つの要素が含まれており、\u0026quot;Links\u0026quot;には「hello world」のIPFSオブジェクトへのtest1.txtとtest2.txtという名前のリンクの配列が格納されています。また\u0026quot;Data\u0026quot;領域は空となっています2。\nまたこのディレクトリのリンク先であるQmT78zSuのIPFSオブジェクトを同じコマンドで調べると、空の”Links\u0026quot;とhello worldが\u0026quot;Data\u0026quot;に格納されているのが見て取れます。\n$ ipfs object get QmT78zSuBmuS4z925WZfrqQ1qHaJ56DQaTfyMUF7F8ff5o {\u0026#34;Links\u0026#34;:[],\u0026#34;Data\u0026#34;:\u0026#34;\\u0008\\u0002\\u0012\\u000chello world\\n\\u0018\\u000c\u0026#34;}    pixabayより拝借したパブリックドメインライセンスの画像をgithubに上げています。 \u0026#x21a9;\u0026#xfe0e;\n 純粋に空ではなく、\u0026quot;\\u0008\\u0001\u0026quot;は含まれていますが・・・ \u0026#x21a9;\u0026#xfe0e;\n   "},{"id":4,"href":"/naming_contents/","title":"IPNSとDNSLink","section":"IPFS入門","content":"IPNSとDNSLink #  これまでIPFSの特徴であるコンテンツ指向のプロトコルは、コンテンツの内容により一意にハッシュ値が決まり、そのハッシュ値によりコンテンツにアクセスする旨を記載してきました。これは IPFSとは何か？でお伝えした通り、ファイルの改竄などを防ぐ有効な手立てとなっています。\nしかし、コンテンツのハッシュ値によるアクセスだけでは不都合が生じる場合もあります。それはコンテンツを更新した場合です。一般的にWeb上のコンテンツは更新や追加がしばしば行われます。その度にアドレスが新しいハッシュ値となってはかなり煩わしい事態になります。\nそのため、IPFSではコンテンツに名前を付ける（Naming: 命名）方策がなされています。それが本節で解説するIPNSとDNSLinkとなります。両者は共にコンテンツに命名する仕組みなのですが、現在のところ、名前解決速度や可読性の高いアドレスを指定できるなどの優位性からDNSLinkがより一般的に利用されています。それぞれについて詳しく見ていきましょう。\nIPNS #  IPNS（Inter Planetary Naming System）はコンテンツのハッシュ値をノードIDに紐付け、コンテンツにアクセスする際にノードIDを経由してアクセスを行うようにする仕組みです。ノードIDはノードを識別するために、重複のない世界に１つだけのIDのため、そのIDをキーとしてコンテンツへアクセスすることを行います。 コンテンツが更新されそのハッシュ値が変わった場合には、ノードIDとコンテンツハッシュの紐付けを更新することでノードIDにより更新されたコンテンツにアクセスができるようになる仕組みです。\nでは実際にIPNSの動作を確認していきましょう。\nまずは非常にシンプルなWebページを作成してみましょう。適当なディレクトリを作成し、その中にindex.htmlを作成します。\n$ mkdir test-page $ vi test-page/index.html index.htmlの内容は例えば以下のように編集します。\n$ cat test-page/index.html \u0026lt;html\u0026gt; \u0026lt;head\u0026gt;\u0026lt;title\u0026gt;test-page\u0026lt;/title\u0026gt;\u0026lt;/head\u0026gt; \u0026lt;body\u0026gt;\u0026lt;center\u0026gt; \u0026lt;h1\u0026gt;It\u0026#39;s a Nice Day!!\u0026lt;/h1\u0026gt; \u0026lt;/center\u0026gt;\u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ここで作成したディレクトリとファイルを下記のコマンドで再帰的にIPFSに追加します。\n$ ipfs add -r test-page/ added QmcC9oDaHU74QgXGxdVcfa3UZVu4cWbGk8JQQRATHNHmRF test-page/index.html added QmXi2mj3KbP6HREi9Vj5keYwTmE1VUrnVxchVyqRWBz3wL test-page ここでIPNSの仕組みを用いて今回作ったテストページのハッシュQmXi2mj3...をノードIDに紐付けます。コマンドは下記の通りです。\n$ ipfs name publish QmXi2mj3KbP6HREi9Vj5keYwTmE1VUrnVxchVyqRWBz3wL Published to QmZdddUUtujd1jqcVd8SLnjbbR9CGQwPUX55AGpWJLjCij: /ipfs/QmXi2mj3KbP6HREi9Vj5keYwTmE1VUrnVxchVyqRWBz3wL ここでアウトプット結果は、ノードIDQmZdddUU...に対してコンテンツQmXi2mj3...が紐付けられたことを示しています。ノードIDに紐付けられたコンテンツはgatewayを通じて下記のURLからアクセスが可能になります。\nhttps://ipfs-gateway.decentralized-web.jp/ipns/QmZdddUUtujd1jqcVd8SLnjbbR9CGQwPUX55AGpWJLjCij/ ここでURLのドメイン以下の最初の部分に注意してください。これまでのアクセスではこの部分はipfsでしたが、IPNSでのアクセスを行う場合はipnsを指定することになります。\n IPNSの仕組みはページのコンテンツが更新されても同一のアドレスでアクセスを可能にするものでした。その動きを確かめましょう。コンテンツを下記の様に内容に追加し、再度ipfs addコマンドでIPFSにコンテンツを共有します。\n$ cat test-page/index.html \u0026lt;html\u0026gt; \u0026lt;head\u0026gt;\u0026lt;title\u0026gt;test-page\u0026lt;/title\u0026gt;\u0026lt;/head\u0026gt; \u0026lt;body\u0026gt;\u0026lt;center\u0026gt; \u0026lt;h1\u0026gt;It\u0026#39;s a Nice Day!!\u0026lt;/h1\u0026gt; \u0026lt;br/\u0026gt; \u0026lt;h1\u0026gt;Let\u0026#39;s go out!!\u0026lt;/h1\u0026gt; \u0026lt;/center\u0026gt;\u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; $ ipfs add -r test-page/ added Qmait5a9gaeFcxV4da7F4kny2NsdCfH1Gjs7YrthizZk23 test-page/index.html added QmZpEhNpd7MCrFrMLKHnvwXSxcjMDYwcGJgkfjg9Z7yy42 test-page 先ほどとコンテンツの内容が変わったため、ハッシュ値も先ほどのものから変化しています。IPNSでは下記のようにipfs name publisコマンドにより更新後のハッシュ値を再度、ノードIDに紐付けなおすことで、更新後のコンテンツも依然と同じアドレスでアクセスできる様にします。\n$ ipfs name publish QmZpEhNpd7MCrFrMLKHnvwXSxcjMDYwcGJgkfjg9Z7yy42 Published to QmZdddUUtujd1jqcVd8SLnjbbR9CGQwPUX55AGpWJLjCij: /ipfs/QmZpEhNpd7MCrFrMLKHnvwXSxcjMDYwcGJgkfjg9Z7yy42 では、先ほどと同様にgatewayを通じて先ほどと同一の下記のURLからアクセスしてみましょう\nhttps://ipfs-gateway.decentralized-web.jp/ipns/QmZdddUUtujd1jqcVd8SLnjbbR9CGQwPUX55AGpWJLjCij/ 下図のように同一URLで更新後のコンテンツが閲覧できることが見てとれます。\n "},{"id":5,"href":"/join_the_network/","title":"コンテンツ共有","section":"IPFS入門","content":"コンテンツ共有 #  前節では単一のノード内で、IPFSの特徴であるコンテンツ指向のプロトコルにおいて種々のファイル（コンテンツ）がどのように扱われるかを見てきました。本節では自身のノードをIPFSネットワークに参加させることで、IPFSがP2Pのネットワークの中で様々なコンテンツがどのように共有されていくのかを見ていきます。\n自身のIPFSノードを接続することで、ノードのリポジトリに登録されたコンテンツはネットワーク上に公開されることになります。そのため公開したくない秘密のコンテンツは接続前に リポジトリを再初期化するなどして削除するようにしてください。  IPFSネットワークへ接続する #  自身のノードをIPFSのP2Pネットワークに追加するにはgo-ipfsをデーモンとして起動します。これによりgo-ipfsは自動でネットワークに接続された他のノード（ピア）を探索し接続する動作が行われます。（もちろん自身のノードがインターネットに接続されている必要があることに注意してください。）\n$ ipfs daemon #go-ipfsをデーモンとして起動 Initializing daemon... go-ipfs version: 0.5.0 Repo version: 9 System version: amd64/linux Golang version: go1.13.10 Swarm listening on /ip4/127.0.0.1/tcp/4001 Swarm listening on /ip4/160.16.52.199/tcp/4001 Swarm listening on /p2p-circuit Swarm announcing /ip4/127.0.0.1/tcp/4001 Swarm announcing /ip4/160.16.52.199/tcp/4001 API server listening on /ip4/127.0.0.1/tcp/5001 WebUI: http://127.0.0.1:5001/webui Gateway (readonly) server listening on /ip4/127.0.0.1/tcp/8080 IPFSノードは他のピアと通信するためにデフォルトではTCPポート4001を利用しています。そのためFirewallなどでポートを閉じている場合は4001を開放してからデーモンを起動してください。  この状態でもう１つ別のターミナルウィンドウを開き、自身のノードの接続状態を見てみましょう。現在自身のノードが接続している他のピアはipfs swarm peersコマンドで確認できます。\nipfs swarm peers |head /ip4/104.236.179.241/tcp/4001/ipfs/QmSoLPppuBtQSGwKDZT2M73ULpjvfd3aZ6ha4oFGL1KrGM /ip4/128.199.219.111/tcp/4001/ipfs/QmSoLSafTMBsPKadTEgaXctDQVcqN88CNLHXMkTNwMKPnu /ip4/178.62.158.247/tcp/4001/ipfs/QmSoLer265NRgSp2LA3dPaeykiS1J6DifTC88f5uVQKNAd （中略） /ip4/98.109.32.211/tcp/4001/ipfs/QmdcDLV5czbEBB1RoYvMxsYUt8KRp5g8GWKsg86cHb2ByD /ip4/98.114.215.177/tcp/36383/ipfs/QmWABRCqWoYCGyGV2PZ2T3D9upV39yMgkmFCprXVsKvAZr /ip4/98.217.220.122/tcp/16006/ipfs/QmVdY2H8ZyWKae7X4HoCkmLeGCw6P9ucqSPSAS9KfeohFf /ip4/99.53.221.81/tcp/4001/ipfs/QmcRw8uibrQmRsbeaCRmFRkxTZG91Jy2WN8kuythaZiopz 出力されている各行が自身のノードと接続しているピアの情報を示しています。非常に多くのピアと接続されているのがみて取れます。筆者の環境では約700のピアと接続されていました。他ピアとの接続数の下限および上限はそれぞれ、IPFSの設定ファイルconfig内1のSwarm.ConnMgrセクションのLowWaterとHighWaterで設定されており、この部分を編集することで変更が可能です。より多くのピアとの接続することでP2Pネットワークの中でアクセスしたいコンテンツが早く見つけることができるため、システムのリソースが許容できる範囲で接続数は多くしておくことが推奨されます。\nコンテンツ共有の動作を見る #  ここまでで自身のノードがIPFSのネットワークに接続されました。これにより自身のノードのリポジトリに登録されているコンテンツもネットワーク上で共有されることになります。実際に前節で登録した\u0026quot;hello world\u0026rdquo;（ハッシュ値QmT78zSu...）のコンテンツの共有状態を見てみましょう。ipfs dht findprovsコマンドで当該ハッシュ値を指定することで、IPFSネットワーク上でこのコンテンツを保持しているピアの情報が取得できます。\n$ ipfs dht findprovs QmT78zSuBmuS4z925WZfrqQ1qHaJ56DQaTfyMUF7F8ff5o QmP5PY85F8XjH5gF67qXLCmU3BxyAW7NdFJ122Vpk8zu7s QmNybVkF2E6j1spYuMDxxpLEUeARB3Fya1w1PLwbLsUBKi QmNkPXCDWZ21tzLhtRqSA2pyAs3CdHkU2txT2JP3f7UrD3 （中略） QmQSsV89WQDv4mQWGUeosYRddDSmGjhpLXPWmJcmGUegKJ QmQ9N2TJCjdX69Z6eRyxkjichXsxHk6zTubHumpSkxPBwR ここでハッシュ値QmT78zSu...のコンテンツ（すなわち”hello world”）は既に多数のピアが保持しているのが分かります2。これは世界中の多くのIPFSユーザーが最初に\u0026quot;hello world\u0026quot;を自身のノードのリポジトリに登録するためと考えられます。IPFSはコンテンツ指向のプロトコルのために、誰がどのようなタイミングでどのピアのリポジトリに登録したかは関係なく同じコンテンツであれば同一のものと扱います。\n誰かがipfs cat QmT78zSu...で\u0026quot;hello world\u0026quot;を取得しようとした場合には、IPFSネットワーク全体に「誰かQmT78zSu...のコンテンツを持っていないか？」という問い合わせを投げ、その結果返事が帰ってきた上記のようなQmT78zSu...を保持するピアのうちもっとも自身に近いピアからコンテンツをダウンロードします。またコンテンツを取得したピアは取得元と同様に他のピアとそのコンテンツを共有することになります。このファイル共有の仕組みにより情報が永続的に保持され続けることになります。この動作はまるで「バカの壁」の書籍を読みたいと思った時に「誰か持っていない？」と周りに問い合わせて、偶然持っていた近くの友人から借りるといった動作と似ていることに気づくと思います。これがコンテンツ指向での情報のやり取りの流れになります。\nこの動作を少し違った角度で見るために、まだ他のピアには登録されていない（であろう）コンテンツでIPFSの動作を見て見ましょう。他のピアには登録されていないようなコンテンツの例として、ここではip addrコマンドの結果をハッシュ化した情報をIPFSネットワーク内で共有してみます3。適当なワーキングディレクトリ以下で\n$ ip addr |sha256sum \u0026gt; ip_hash.txt $ cat ip_hash.txt 01a0e60650c96bca05be0ed61c2ed0e79773f924eba38893d7c5527e0771b6ea - $ ipfs add ip_hash.txt added QmX5HrsXKMwBPG6gcHyXnZ9TvjpUTxSAGJPczQQWptqbo1 ip_hash.txt を実行しIPFSネットワークに登録します。\n$ ipfs dht findprovs QmX5HrsXKMwBPG6gcHyXnZ9TvjpUTxSAGJPczQQWptqbo1 QmP5PY85F8XjH5gF67qXLCmU3BxyAW7NdFJ1h8Vpk8zu7s 今回のコンテンツは世界に一つしかないコンテンツのため、このコンテンツを保持しているピアは自分自身だけです。さて、この状態でパブリックゲートウェイを経由してブラウザからこのコンテンツを取得してみましょう。chromeなどのアドレスバーに\nhttps://ipfs-gateway.decentralized-web.jp/ipfs/QmX5HrsXKMwBPG6gcHyXnZ9TvjpUTxSAGJPczQQWptqbo1 を入力してアクセスします。ここでURL末尾のQmX5HrsX...は自身の環境でのハッシュ値に置き換えてください。ブラウザ上でコンテンツが表示されるはずです。その後もう一度このコンテンツを保持しているピアを表示させるコマンドを実行すると\n$ ipfs dht findprovs QmX5HrsXKMwBPG6gcHyXnZ9TvjpUTxSAGJPczQQWptqbo1 QmP5PY85F8XjH5gF67qXLCmU3BxyAW7NdFJ1h8Vpk8zu7s QmVU5iBx5a8tKJimkPzn3mzeGfEW8LjwgZV1xV4yu4bjaD のようにパブリックゲートウェイのピアQmVU5iBx...にもコンテンツが保持されているのがみて取れます。これはブラウザからコンテンツ取得を依頼されたパブリックゲートウェイのピアからIPFSネットワークにコンテンツの保持者を問い合わせ、保持しているipfs addをしたピアからコンテンツを取得しブラウザに返却。コンテンツをパブリックゲートウェイのピアに保持し続けている状態になります。\nここで https://ipfs-gateway.decentralized-web.jp/は筆者が開設しているパブリックゲートウェイです。Protocol Labsの開設している本家のパブリックゲートウェイ（ https://ipfs.io/ipfs ）は、保持期間を極端に短くしている（またはコンテンツの保持をしないようしている？）ため、上記のようなIPFSの仕様通りの標準的な動作をしません。そのためここでは筆者が開設しているパブリックゲートウェイを指定して標準的な動作を見るようにしています。    通常は$HOME/.ipfs/config。ここで$HOMEは（IPFSを起動した）ユーザーのホームディレクトリ。 \u0026#x21a9;\u0026#xfe0e;\n 実際はより多いピアでコンテンツが共有されていますがコマンドの仕様上20件に限定されて表示されています。 \u0026#x21a9;\u0026#xfe0e;\n ifconfigコマンドはIPアドレスなどのネットワーク情報の他にネットワークインターフェースの累積トラフィック量などが出力されるため、同じサーバ内でも出力の内容が変わり世界で唯一のコンテンツを作成するのに便利です。 \u0026#x21a9;\u0026#xfe0e;\n   "},{"id":6,"href":"/building_public_gateway/","title":"パブリックゲートウェイの構築","section":"IPFS入門","content":"パブリックゲートウェイの構築 #  これまで述べきたとおりIPFSネットワークはHTTPプロトコルをベースとした既存のインターネットとは異なる独立したネットワークです。そのためIPFSのネットワークにインターネット（つまり既存のブラウザ）からアクセスするためにはIPFSネットワークへ橋渡してくれる場所を経由してアクセスする必要があります。その橋渡し役を担うのがIPFSゲートウェイであり、その中でも任意のユーザーに常時公開されているものをIPFSパブリックゲートウェイと呼びます。パブリックゲートウェイはいくつかあり、先の章で出てきたhttps://ipfs.io/ipfsや https://ipfs-gateway.decentralized-web.jp/がそれに当たります。\nもちろんこれらの既に公開されているゲートウェイ経由でIPFSネットワークへアクセスすることも可能ですが、あなたが技術的に興味があれば自身でゲートウェイを構築し公開することも可能です。本章ではパブリックゲートウェイ構築方法の例を示します。\nリバースプロキシを利用した構築 #  本章末尾のNoteに記載のとおりgo-ipfsを設定変更するだけで手軽に自身のIPFSノードをパブリックゲートウェイを構築することはできます。しかしこの方法は、httpのアクセスのみでhttpsでのアクセスを許可することができないこと、セキュリティ面での懸念があること、さらにアクセスが増えた場合の負荷分散が難しいというように、多くのデメリットがあります。そのためにWebサーバ（ここではnginxを想定します）をリバースプロキシとして利用しgo-ipfsへのアクセスを中継する方法を取るのが一般的です（下図）。\n 以下にUbuntu 16.04 LTS環境での具体的な手順例を示します。（以降、go-ipfsが稼働するサーバがグローバルIPアドレスとドメインを持っておりDNS設定されている前提で進めます。）\n1. go-ipfsの自動起動設定 #  先にインストールしているgo-ipfsをサーバ再起動時などに自動起動する設定を行います。\n$ sudo vi /lib/systemd/system/ipfs-daemon.service で下記の内容が記されたファイルを生成します。ここではコマンド/usr/local/bin/ipfs daemonがubuntuユーザー＆グループで実行されることを指定しています。（その他の設定の詳細については ここが参考になります。）\n[Unit] Description=ipfs daemon [Service] ExecStart=/usr/local/bin/ipfs daemon Restart=always User=ubuntu Group=ubuntu [Install] WantedBy=multi-user.target 用意したファイルでの自動起動を有効化し、実際にサーバ再起動時にgo-ipfsが自動起動されるかを確認します。\n$ sudo systemctl enable ipfs-daemon Created symlink from /etc/systemd/system/multi-user.target.wants/ipfs-daemon.service to /lib/systemd/system/ipfs-daemon.service. $ sudo shutdown -r now #自動起動されるか実際にサーバ再起動し確認。 $ ps aux |grep ipfs #プロセス確認 ubuntu 639 1 4 11:21 ? 00:00:05 /usr/local/bin/ipfs daemon ubuntu 942 929 0 11:23 pts/0 00:00:00 grep --color=auto ipfs 2.リバースプロキシに用いるnginxのインストールと設定 #  webサーバはapacheなどもありmod_proxyを導入することでリバースプロキシとして利用することも可能ですが、ここではwebサーバとしてnginxを採用したいと思います。nginxをまずサーバにインストールします。\n$ sudo apt-get update $ sudo apt-get upgrade $ sudo apt-get install nginx 下記ファイル内容のようにnginx設定をviなどを用いて当該ファイル内容を変更します。\n$ cat /etc/nginx/sites-available/default # http(80番ポート)アクセスをhttps(443番ポート)にリダイレクトする設定 server { listen 80; server_name ipfs-gateway.decentralized-web.jp; return 301 https://$host$request_uri; } # httpsへのアクセスを受けた場合の設定 server { listen 443 ssl default_server; index index.html index.htm index.nginx-debian.html; # SSL証明書関連の設定。 # 証明書はLet\u0026#39;s encrypt（https://letsencrypt.org/）を利用して用意。 # 設定内のドメインは各環境に合わせること。 server_name pfs-gateway.decentralized-web.jp; ssl_certificate /etc/letsencrypt/live/ipfs-gateway.decentralized-web.jp/cert.pem; ssl_certificate_key /etc/letsencrypt/live/ipfs-gateway.decentralized-web.jp/privkey.pem; # バックエンドのgo-ipfsとの連携設定。 # ドメイン以下のアクセス全て（/）を/var/www/html以下のindex.htmlへ。 location / { root /var/www/html; } # ドメイン以下/ipfs/か/ipns/の場合はgo-ipfsへ。 location ~*/ip[fn]s/.+ { proxy_pass http://127.0.0.1:8080; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \u0026#39;upgrade\u0026#39;; proxy_set_header Host $host; proxy_cache_bypass $http_upgrade; } } 上記nginxの設定ファイル内のコメントにも書いたようにHTTPS通信する際の証明書は Let\u0026rsquo;s encryptを利用して証明書を発行しています。証明書発行は自動で行われ容易にかつ手早く発行が可能です。Let\u0026rsquo;s encryptについては ここで詳しく解説してくれているので参考にしてください1。\n最後にもう一度サーバ再起動を行いnginxとgo-ipfsが自動起動されることや所定のアドレスにブラウザからアクセスしコンテンツが表示されることを確認して完了です。\n上記の手順はFirewallの設定などセキュリティ関連の手順は割愛しています。不特定多数のアクセスを許可するサーバとしての十分なセキュリティ対策は別途必ず行うようにしてください。  パブリックゲートウェイを構築する最も簡単な方法は、go-ipfsの設定ファイル[^1]内のAddresses項目で\u0026quot;Gateway\u0026quot;: \u0026quot;/ip4/127.0.0.1/tcp/8080\u0026quot;とローカルホストのみが許可されているところを、全てのIPアドレスからのアクセスを許可するように\u0026quot;Gateway\u0026quot;: \u0026quot;/ip4/0.0.0.0/tcp/8080\u0026quot;に変更することです。この設定状態でipfs daemonコマンドを実行すれば、任意のクライアントのブラウザから、たとえばURLhttp://[当該サーバIPアドレス]:8080/ipfs/QmT78zSuBmuS4z925WZfrqQ1qHaJ56DQaTfyMUF7F8ff5oにアクセスすることが可能になります。しかし、本文中に記載のとおりセキュリティや運用の側面からこの方法はあまり推奨されません。    もちろん 公式ドキュメントも充実しています。 \u0026#x21a9;\u0026#xfe0e;\n   "},{"id":7,"href":"/ipfs-whitepaper-jp/","title":"参考：whitepaper 日本語訳","section":"IPFS入門","content":"参考：whitepaper 日本語訳 #  本章は参考情報として Juan Benet によって書かれたIPFSの whitepaper「IPFS-Content Addressed, Versioned, P2P File System (DRAFT 3)」の日本語訳を記します。\n本翻訳は直訳を避け、原文の内容を損ねない範囲で（大幅に）意訳しています。そのため必要な場合は 原文を参照ください。また、翻訳への協力（翻訳・修正）歓迎です。協力いただける場合は GitHubにてIssueの発行、またはPull requestをお願いいたします。  概要 #  Inter Planetary File System(IPFS)はピアツーピア（\u001cP2P）型の分散型ファイルシステムであり、全てのデバイスを一つのファイルシステムに結合することを目的としたものです。いくつもの点でIPFSはWebと同様のもの言えますが、一方で、一つのGitリポジトリ上でオブジェクト交換を行うBitTorrentのスウォームと考えることもできます。またはコンテンツアドレス型のハイパーリンク機能をもつストレージとも考えられます。IPFSはMerkle DAGのデータ構造を持ちます。IPFS上にバージョン管理可能なファイルシステムやブロックチェーン、または永続的なWebを構築することが可能になります。IPFSは分散ハッシュテーブル技術、インセンティブが与えられたブロック交換技術、自己証明型名前空間といった要素技術を組み合わせて実現されており、単一障害点がなくピア同士がお互いの信頼を必要とせずに実現できるシステムです。\n1. 序論 #  これまで多くのグローバルな分散ファイルシステムを構築する試みがなされてきました。いくつかは顕著な成果を見せましたが、その他は完全に失敗に終わりました。例えば学術的な取り組みとしては、AFS[6]が成功事例として挙げられ現在も活用されている一方で、その他[7,?]の試みは失敗に終わっています。学術的な試み以外でのP2P型の分散ファイルシステムは大容量コンテンツ（音楽や動画など）の共有用途に発展してきました。特にNapsterやKaZaA、BitTorrent[2]といったアプリケーションは1億人以上のユーザーによって支えられる巨大な分散システムでした。今日でもBitTorrentは1,000万ものノードが動作している巨大なファイルシステムとして動作し続けています[16]。これらのアプリケーションは、学術的な取り組みの中でのファイルシステムよりも多くのユーザーを惹きつけてきました。しかしこれらは別目的で利用される事例1はあるものの、あくまでアプリケーションであり、その上でシステムやアプリケーションが動作するインフラ基盤としてデザインされているものではありません。その点で、一般的なファイルシステムとして利用可能な、グローバル規模で低レイテンシー分散ファイルシステムというものはこれまで現れてきていないといえます。\nこの理由は既に十分良いシステムが存在していたからと考えられます。「HTTP」です。HTTPはこれまで最も成功した分散ファイルシステムプロトコルです。ブラウザと結びつくことでHTTPは技術的にも社会的にも多くのインパクトを与え、インターネット上でのファイル転送のデファクトスタンダードとなっています。しかしHTTPはそれが世に出て以降の15年の間に生み出されてきた新たな技術を取り込むことには失敗しています。多くの後方互換性の確保やステークホルダーの複雑なしがらみから、Webのインフラ基盤を進化させることは事実上不可能に見える一方で、実際にはHTTPの出現以降も様々な新しいプロトコルが生み出され広範囲で利用されている事実もあります。ユーザーエクスペリエンスを損なうことなく新たな機能を導入するようなHTTP-Webのグレードアップを行なっていく必要があります。\nHTTPプロトコルは小容量のデータのやりとりに関して比較的安価で行うことを実現する一方で我々はデータ転送に関して新たな時代に突入しつつあります。それは(a)ペタバイト級データのホストと配信 (b)組織横断の大量データ処理 (c)大容量高精細なオンデマンドのコンテンツストリーミング(d)大規模データのバージョン管理およびリンク処理(e)重要データの消失防止、というようなものが要求される時代です。このような状況のもと、我々はHTTPを捨てて新たなデータ転送プロトコルを開発しました。次のステップはこれをWebそのものにすることが必要です。\nデータ転送と同等に、バージョン管理技術はデータ操作の協調作業に重要な役割を果たしてきました。ソースコード分散バージョン管理システムであるGitは分散されたデータ操作の実装モデルとして非常に重要であり、Git関連技術は従来の大容量ファイルシステムにはなかったバージョン管理機能の実現を可能にします。Camlistore[?]やDat[?]といったGitにインスパイアされたシステムも出現しています。またGitは「コンテンツアドレスMerkle DAG」形式のデータモデルを採用しており、この方式は既に分散ファイルシステムに影響を与えています。\n本論文ではバージョン管理機能を備えた新しいファイルシステムであるIPFSについて解説します。IPFSは「全てのデータを統一されたMerkle DAGにモデリングする」という基本原則のもとに設計されています。\n2. 背景 #  本節では、IPFSが融合しようとしているP2Pシステムの重要な技術について振り返ります。\n2.1 分散ハッシュテーブル #  分散ハッシュテーブル（Distributed Hash Table: DHT）は、P2Pシステムにおいてメタデータを統合し管理するために広く用いられているものです。例えば MainlineDHTはBitTorrentでピアのトラッキングに利用されています。\n2.1.1 Kademlia DHT #  Kademliaは広く知られたDHTであり、下記のような特徴があります。\n 高効率のデータ探索：システムのノード数をnとしたとき、問い合わせ先のノード数は平均 log2(n)のオーダーとなります。（例えば、10,000,000ノードであれば20ホップでデータ探索が可能です。） コーディネーションの低いオーバーヘッド：ノード間でやりとりされるコントロールメッセージ数が最適化されます。 より長く接続されているノードを重視することで耐攻撃性を実現しています。 GnutellaやBitTorrentなど多くのP2Pシステムで実際に利用されており、2,000万ノードのネットワークを形成している実績があります。  2.1.2 Coral DSHT #  いくつかのP2Pファイルシステムはデータブロックを直接DHTに格納する手法を取っていますが、この方法は格納する必要のないノードにもデータを格納する必要性を発生させるため、ストレージとネットワーク帯域を必要以上に消費する欠点があります[5]。Coral DSHTはKademliaを以下の３つの重要な点で拡張した方式です。\n Kademliaはデータブロックを格納するノードをデータのキーと最も距離（XOR距離）が近いIDをもつノードに決定します。この時、たとえ離れていてもより頻繁にデータを必要とするノードなどという、アプリケーション側のデータの局所性については考慮されません。そのため、ストレージとネットワーク帯域を必要以上に消費する欠点があります。代わりにCoralではデータブロックを格納する「アドレス」を最も距離が近いノードに格納します。 Coralは分散ハッシュテーブルのAPIをget_value(key)からget_any_values(key)と緩和（Distributed Sloppy Hash TableのSloppyの由来）しています。これによりkeyへのアクセスが増加した際に特定のノードに負荷が集中しホットスポットになることを防いでいます。 Coralはサイズや地域に応じてDSHTのクラスターの階層を形成します。これにより距離の遠いノードへの問い合わせ数を減らし[5]、探索のレイテンシーを軽減しています。  2.1.3 S/Kademlia DHT #  S/Kademlia[1]は、悪意の攻撃を防ぐために、以下の２点についてKademliaを拡張しています。\n S/KademliaはPKI鍵ペアを利用したセキュアなノードのID生成スキームを導入することによりシビル攻撃を防ぎます。 S/Kademliaでは連結されていないパスも対象にデータを探索します。これにより多くの悪意あるノードが含まれるネットワークにおいても善意のノード同士が接続可能にします。実際に半数の悪意あるノードが含まれるネットワーク内においても0.85という（訳者注：データ探索の？）成功率を実現しています。  2.2 ブロック交換 - BitTorrent #  BitTorrent[3]はファイル共有システムとして大きく成功しているシステムです。信頼性の低いピア（スウォーム）が存在するP2Pネットワークにおいても各ピアが連携してファイルピース（ファイル断片）の共有を行う仕組みを作ることに成功しています。IPFSのデザインに影響を与えたBitTorrentの特徴は以下のものです。\n BitTorrentでのデータ交換プロトコルは「擬似しっぺ返し(tit-for-tat)戦略」と呼ばれる、貢献するノードにはより多くの褒賞を与えて、単に他者のリソースを取得するだけのノードには罰則を与えるという仕組みを採用しています。 BitTorrentではファイル断片の希少性をトラッキングし、最も希少なファイル断片から優先してダウンロードするように設計されています。これによりシーダー（ファイルの完全なデータを持つピア）の負荷を下げ、シーダーでないピアもデータ交換に参加出来るようにしています。 BitTorrent標準のしっぺ返し戦略は、略奪的帯域幅共有戦略（exploitative bandwidth sharing strategies）に対して脆弱性を持ちます。PropShare[8]戦略はこの種の脆弱性を克服し、かつスウォームのパフォーマンスを改善する戦略として知られます。  2.3 バージョン管理システム - Git #  バージョン管理システムはファイルシステムに対する変更履歴を管理し、かつその各バージョンを効率的に配布することを容易にしてくれます。バージョン管理システムとして普及しているGitは、ファイルシステム内の変更履歴をMerkle DAGのオブジェクトにモデル化することで分散システムに親和性の高いシステムになっています。\n ファイル (blob)、ディレクトリ (tree)、そして変更 (commit)は、それぞれ不可変（イミュータブル）なオブジェクトとして表現されます。 それらのオブジェクトはコンテンツから生成されたハッシュ値そのものをアドレスとして参照されます（コンテンツアドレス）。 オブジェクト間がリンクにより参照されることで Merkle DAGを構成します。 ブランチやタグ等のバージョン管理用のメタデータは単なるポインターとして管理されるため、それらの生成や更新にはほとんどコストはかかりません。 バージョンの変更はそれらポインターの変更と差分のオブジェクトの追加として管理されます。 バージョン変更の他ユーザーへの配布はオブジェクトの転送とリモート参照の更新です。（＊訳者注：この部分は意味不明です。）  2.4 自己証明型ファイルシステム - SFS #  自己証明型ファイルシステム（SFS） [12, 11] は、(a) 分散トラストチェーン、(b) 平等でグローバルな名前空間　の２つを実現するための実装です。SFSはこれらを実現するためにリモートファイルシステムのアドレスを\n/sfs/\u0026lt;Location\u0026gt;:\u0026lt;HostID\u0026gt; というスキームに定義しています。ここで、Locationはサーバのネットワークアドレスであり、HostIDは\nHostID = hash(public_key || Location) で定義されます。このことからSFSファイルシステムでの名前自体がそのサーバ（の正当性）を証明することになります。ユーザーはサーバによって提供される公開鍵を検証し共有鍵を交換することで全ての通信を秘匿化します。全てのSFSのインスタンスはグローバルで暗号学的な名前空間を共有するため、何らかの中央機関による管理が必要としません。\n3. IPFSの設計 #  IPFSは先述したDHT、BitTorrent、Git、SFSのアイデアを融合して実現する分散ファイルシステムです。IPFSはこれらの技術を単純化し進化させ一つの技術として融合しています。IPFSは、そこにアプリケーションをデプロイして動作させる新たな基盤として、または新たな大容量データのバージョン管理や配布を行うシステム基盤として活用を可能にするものです。IPFSはwebそのものを進化させる可能性もあります。IPFSはP2Pであり特別なノードを必要としません。 IPFSノードはそれぞれののローカルストレージにIPFSオブジェクトを格納し、ノード同士が繋がり合いこれらのオブジェクト（つまりデータ）を交換します。 IPFSプロトコルは下記の各々個別の役割をもつサブプロトコルに分離することができます。\n Identities - ノードIDの生成と検証を管理します。3.1節に詳述します。 Network - 下位の様々な通信プロトコルを利用して他ピアとの接続を管理します。3.2節に詳述します。 Routing - 特定のピアやオブジェクトのロケーション情報を管理し、ローカルやリモートからの問い合わせに対して情報を返します。デフォルトではDHTが利用されますが、変更可能です。3.3節に詳述します。 Exchange - 効率的な新型ブロック交換プロトコルであるBitSwapです。ブロックの市場としてモデリングされ、データの複製を緩やかに誘引します。ブロック交換の戦略は変更可能です。3.4節に詳述します。 Objects - コンテンツアドレス型の不可変（イミュータブル）でリンクをもつMerkle DAGです。ファイルシステムの階層やコミュニケーションシステムなど、任意のデータ構造を表現することが可能です。3.5節に詳述します。 Files - Gitに影響を受けたバージョン管理ファイルシステムです。3.6節に詳述します。 Naming - 自己証明可能かつ変更可能な名前空間システムです。3.7節に詳述します。 これらのサブシステムはそれぞれ独立している訳ではなく、互いに影響し合っています。しかし分かりやすさのため、これらを切り離されたプロトコルスタックとして記述します。  注：下記にデータ構造や機能はGo言語の文法に従い記述します。\n3.1 Identities #  各ノードはNodeIdによって識別され、これはS/Kademliaで交換される公開鍵を暗号学的ハッシュ関数によりハッシュ化したものとなります[1]。各ノードは自身の公開鍵と（パスワードにより暗号化された）秘密鍵を保持します。ノードの管理者はノードを起動する度に新しいIDを発行することも可能ですが未払いのネットワーク報酬を放棄することとなるため、それが同じIDを使い続けるインセンティブとなります。\ntype NodeId Multihash type Multihash []byte // self-describing cryptographic hash digest type PublicKey []byte type PrivateKey []byte // self-describing keys type Node struct { NodeId NodeID PubKey PublicKey PriKey PrivateKey } difficulty = \u0026lt;integer parameter\u0026gt; n = Node{} do { n.PubKey, n.PrivKey = PKI.genKeyPair() n.NodeId = hash(n.PubKey) p = count_preceding_zero_bits(hash(n.NodeId)) } while (p \u0026lt; difficulty) IPFSではS/Kademlia方式を基礎にしたID生成を行います。最初に他ノードと接続する際には公開鍵を公開しhash(other.PublicKey)がother.NodeIdと一致するかを確認します。もし異なる場合は接続を遮断します。\n暗号学的関数について #  IPFSでの暗号学的ハッシュ値は、何らか特定の関数を使用することをに限定せず、自己表示的な値をもつようにしています。つまり下記のようにマルチハッシュのフォーマット、すなわち、値の先頭部分に使用されたハッシュ関数やダイジェストのバイト数を示すヘッダを持つようにしています。\n\u0026lt;function code\u0026gt;\u0026lt;digest length\u0026gt;\u0026lt;digest bytes\u0026gt; これはシステムに対して (a)ユースケース（例えば強固なセキュリティが必要か？それとも速度が重要か？）に合わせてベストな関数を選択する可能にし、(b)暗号の進化に合わせてシステムも進化可能にします。そしてどの関数を利用したものかを自己表示することにより異なる関数の場合でも互換性を確保しています。\n3.2 Network #  IPFSのノードはインターネットを横断して常に100以上もの他ノードと通信しています。IPFSのネットワークスタックには次のような特徴があります。\n トランスポート: IPFSは任意のトランスポート層のプロトコルが利用可能です。特にWebRTC DataChannels[?] (ブラウザ間接続)やuTP(LEDBAT [14])のようなプロトコルに親和性が高いものとなっています。 信頼性: IPFSはuTP (LEDBAT [14])やSCTP [15]を利用することで、下層のネットワークプロトコルが信頼性を持たない場合でも信頼性を確保することが可能です。 接続性: IPFSはICE-NAT-traversal[13]を利用しています。 整合性: IPFSでは任意でハッシュ関数のチェックサムを利用してメッセージ整合性をチェックすることが可能です。 メッセージ認証: IPFSでは任意で送り主の公開鍵とHMACを利用して、メッセージ認証を行うことがß可能です。  3.2.1 ノードアドレス指定 #  IPFSでは任意のネットワークが利用可能です。それは即ち、必ずしもインターネットプロトコル（IP）にアクセスすることを想定しておらず、また依存していることもありません。そのためIPFSはオーバーレイネットワークとして利用が可能です。IPFSはmultiaddrにバイト文字列としてアドレスを保持します。multiaddrでは下記の例のようにプロトコルの種類とそのアドレスが格納され下層のネットワークに伝えられます。\n# an SCTP/IPv4 connection /ip4/10.20.30.40/sctp/1234/ # an SCTP/IPv4 connection proxied over TCP/IPv4 /ip4/5.6.7.8/tcp/5678/ip4/1.2.3.4/sctp/1234/ 3.3 Routing #  IPFSのノードは２つのルーティングを行う必要があります。つまり(a)他のノードのネットワークアドレスへのルーティング、(b)オブジェクトのホストする場所へのルーティング、の２つです。IPFSではこれらのルーティングをS/KademliaとCoralを基礎としたDSHTを用いることで実現しています。IPFSでは、Coral[5]やMainline[16]と似たオブジェクトのサイズと利用方法を採用しています。つまりIPFSでは保存するオブジェクトのサイズにより保存方法を切り分けます。1KB以下の小さいサイズのオブジェクトの場合そのオブジェクトを直接DHT上に保存し、それを超えるサイズのオブジェクトの場合はそのオブジェクトへの参照（＝保持しているノードのID）をDHT上に保存します。 このDSHTのインターフェースは次のようなものです。\ntype IPFSRouting interface { FindPeer(node NodeId) // gets a particular peer’s network address SetValue(key []bytes, value []bytes) // stores a small metadata value in DHT GetValue(key []bytes) // retrieves small metadata value from DHT ProvideValue(key Multihash) // announces this node can serve a large value FindValuePeers(key Multihash, min int) // gets a number of peers serving a large value } 注意: IPFSではユースケースに応じて異なる実装がコールされます。（例えば広域ネットワークではDHTが、ローカルネットワークではstatic-HTがコールされます。）そのためIPFSでは上記のインターフェースに準拠する限りユーザーのニーズに応じてルーティングシステムが切り替えることが可能です。\n3.4 ブロック交換 - BitSwapプロトコル #  IPFSでのデータ配布はBitSwapプロトコルに準拠したピア間のブロック交換によって行われます。BitSwapプロトコルはBitTorrentに強く影響されたプロトコルであり、BitTorrentと同様に各ピアは自分が取得したいブロックのリスト(want_list)と、自分が提供できるブロックのリスト(have_list)を保持します。一方でBitTorrentと異なりBitSwapは１つのTorrentに限定せず、そのブロックがどのファイル（Torrent）の一部かに関係なくブロック交換を行う一種の永続的なブロックの交換市場のように振舞います。ノードはそのブロック交換市場に寄り合ってブロックを交換することになります。交換市場が形成されることは即ち仮想通貨とその取引を登録する台帳が必要になることを意味しますがこれについては今後の論文にて議論することにします。\n最も基本的なブロック交換のケースは２つのノード間で直接ブロックを交換しあうことです。しかしこれはお互いに保持しているブロックが相補的、つまり他者が必要なブロックを自身が持っていることが必要となります。しかしこのようなケースはまれであるため、多くの場合で自分が必要なブロックを取得するために他者が必要とするブロックを探し出し保持することでブロック交換が可能になります。これは各ノードが自分自身が必要でないブロックも保持することのインセンティブとして働きます。\n3.4.1 BitSwapにおいての信用 #  BitSwapプロトコルにおいてノードは貸しが帰ってくることを期待して楽観的にブロックを他者ノードに送ります。しかしリーチノード（ブロックを他者に一切シェアすることなくブロックを受け取るのみのノード） からは守る必要があります。そのためBitSwapプロトコルでは単純な信用システムを構築しそれを解決します。\n ノードは（他者ノードと送受信したブロックのバイト単位での）収支をトラッキングします。 ノードは債務ノード（受信ブロックのバイト数が送信ブロックのそれよりも大きいノード）にはその債務が増えるに従い小さくなる確率関数にしたがい、確率的にブロックの送信を行います。  上記の仕組みでノードが特定の他者ノードに送信を行わないことになった場合、その後ignore_cooldownの時間だけ経過するまではその他者ノードを無視し続けることに注意してください。これは確率が低くても試行回数が多くなると送信のチャンスが増えてしまうことを防ぐためです。（BitSwapプロトコルではデフォルトで10秒に設定されています。）\n3.4.2 BitSwap戦略 #  BitSwapのピアは多種多様なブロックの交換戦略を取りうり、しかもどの戦略をとるかはネットワーク全体のブロック交換効率を左右します。BitTorrentでは標準の戦略(しっぺ返し戦略)が指定されているものの、様々な非正規な戦略も実装されており、例えば BitTyrant[8]（最も少ない物をシェアする）、BitThief[8]（脆弱性を突き何もシェアしない）、PropShare [8]（比例的にシェアする）というような戦略があります。このような様々な戦略は、それが良い戦略か悪意ある戦略かに関わらずBitSwapのピアでも実装されるでしょう。そこでBitSwapプロトコルでのブロック交換戦略は下記の目的を満たしておく必要があります。\n 自身のノードの交換効率、そしてネットワーク全体の交換効率を最大化すること。 悪意あるノードにより脆弱性を突かれることや、ネットワーク全体の交換効率低下を防ぐこと。 未知の交換戦略に対して効率的かつ耐性を持つこと。 信用あるノードには寛容であること。  交換戦略についての探索は今後の仕事としてここでは多くは触れません。一つの実用的な戦略関数は負債比率によってスケールされたシグモイド関数でしょう。ここで、あるノードに関してそのピアとの負債比率 r を、\n  \\[r = \\frac{{\\rm bytes＿sent}}{{\\rm bytes＿recv \u0026#43; 1}}\\]  とした時、そのノードがピアにブロックを送信する確率を\n \\[P(send|r) = 1 - \\frac{1}{1 \u0026#43; exp(6 − 3r)}\\]  とします。 Figure 1 に示されるようにこの関数はそのノードの負債比率が２を超えるあたりから急速に減少するものとなっています。 (※訳者注：レンダリング不具合からか 原文でもここに表示しているように関数が描画されていない空のグラフになっています。訳者が 当該関数を描画したものをGithub上に置いたので興味があれば参照ください。)\n 負債比率は信用の一つの指標として働きます。つまり多くのデータを交換してきた実績のあるノードに対しては寛容に、一方で未知で信用ができないノードについては厳しい送信確率になるというものです。これにより（a）多くの新しいノードを作るようなシビルアタックを狙う悪意ある攻撃者に対して耐性を持つことを可能にする（b）一時的にブロックを提供できない状態になった場合にも過去に十分交換実績があるノードは保護する（c）修復されないノードに対して最終的に交換を停止するという動作が可能になります。\n3.4.3 BitSwap Ledger #  BitSwapのノードは他のノードとのブロック転送収支の台帳を持ちます。BitSwapノード間で接続を開始する際はこの台帳を互いに交換します。この台帳に齟齬がある場合はこの台帳の信用と負債の記録を消し初期化することも可能です。悪意あるノードが負債の歴史を隠すために消すことがありえます。ノードが十分に負債を蓄積することはほぼないでしょう。（訳者注：意味不明）接続先のノードはブロックの取引を中断することが可能です。\ntype Ledger struct { owner NodeId partner NodeId bytes_sent int bytes_recv int timestamp Timestamp } ノードは台帳の履歴を残すこともできます。ただしブロック取引を行うのには現時点での台帳の値のみが必要で履歴は必須ではありません。ノードは古い台帳（すでに存在しないノードとの取引実績）などを自由に捨てる（Garbage Collect）ことも可能です。\n3.4.4 BetSwapの仕様 #  BitSwapのノードはシンプルなプロトコルに従います。\n// Additional state kept type BitSwap struct { ledgers map[NodeId]Ledger // 既知のノードに関する台帳リスト（未接続のノードも含む） active map[NodeId]Peer // 現在接続しているノードリスト need_list []Multihash // 自分が必要としているブロックのチェックサムのリスト have_list []Multihash //　自分が持っているブロックのチェックサムのリスト } type Peer struct { nodeid NodeId ledger Ledger // このピアとの取引台帳 last_seen Timestamp // 最後にメッセージを受信したタイムスタンプ want_list []Multihash // このピア（またはこのピアのピア）が必要としているブロックのチェックサムのリスト } //プロトコルのインターフェース: interface Peer { open (nodeid :NodeId, ledger :Ledger); send_want_list (want_list :WantList); send_block (block :Block) -\u0026gt; (complete :Bool); close (final :Bool); } ピアとの接続を行う際の流れは以下のようなものになります。\n Open: ピアがledgerを同意するまで送信。 Sending: ピア同士でwant_listとblocksを交換します。 Close: ピアが接続を閉じます。 Ignored: （特別）ノードがブロック送信をしない場合はそのノードは一定期間無視されます。  ◆ Peer.open(NodeId, Ledger) #  他ノードと接続を行おうとする際、まずノードはその相手のノードとのブロック交換履歴を保存した（または新しい）ブロック交換履歴台帳であるLedgerを送信し、 その後Openメッセージを相手側に送信します。\nOpenメッセージを受け取ったノードはその接続を受け入れるか拒否するかを判断します。例えば受信側で保存しているLeadgerの記録からそのノードが信用できない場合（例えばブロック交換の負債が大きいなど）に接続を拒否します。この接続拒否についてはignore_cooldownのタイムアウト設定を考慮しつつ確率的に行われるべきものです。\n一方で接続を開始する場合、受信側はPeerオブジェクトのLedgerを受信側のローカルに保持しているオブジェクトに設定しlast_seenタイムスタンプを更新します。そして受け取ったLeadgerと内容を比較して、それらが正確に一致している場合はそのまま接続を開始します。またもし一致しない場合は新たにゼロに初期化された台帳を生成し相手に送信します。\n◆ Peer.send_want_list(WantList) #  ノード間の接続が開いている間、ノードは自身のwant_listを接続している全ノードに周知します。この周知は（a）接続が開始された際、（b）ランダムに設定されたタイムアウト時間を超えた場合、（c）want_listの内容が変化した場合、（d）新しいブロックを受信した場合、の４つケースをトリガに行われます。\nwant_listを受信した側は、そこに記述されたブロックを自身が保有しているかをチェックし、もし保有している場合は上述のBitSwap戦略に沿ってブロックを送信します。\n◆ Peer.send_block(Block) #  ブロックの送信方法は比較的わかりやすいものとなっています。ノードは単純にデータブロックを送信します。受信側はブロックを全て受け取った後、それが望んだものと一致するかをマルチハッシュのチェックサムを計算して確認し、確認結果を返信します。\nブロック交換が完了する際に、受け手側は受け取ったブロックについての記述をneed_list（訳者注：want_listの間違いと思われます）からhave_listに移動させます。また送受信側の両ノードで、今回行ったブロック交換について台帳に記録し更新します。\n仮にチェックサムが一致しない場合は、送信側のノードが正常に動作していないか悪意あるノードであるかのどちらかになります。受け手側が今後もこのノードと取引を続けるかは受信ノード自身の判断に任されます。BitSwapは信頼性のあるネットワークプロトコルで動作していることを想定して動作しているため、仮にネットワークで問題に起因してブロック送受信に異常がある場合はそのネットワーク上で既に異常検知されているはずです。\n◆ Peer.close(Bool) #  finalパラメーターはcloseによる接続遮断が送信側の意図か否かを示すものです。もしこのパラメータがfalseの場合は受信側で接続を再開することが可能です。これは時期尚早な接続遮断を防ぐためです。\n接続遮断は以下の２つのケースで行われます。\n silence_waitタイムアウト時間（デフォルト30秒）を超えて接続先のノードから何もメッセージが送られてこない場合にノードはPeer.close(false)を発行します。 ノードがIPFSネットワークから離脱する場合、BitSwapの取引をやめる場合、そのノードはPeer.close(true)メッセージを発行します。  closeメッセージを受信後は送信側と受信側共に、全ての状態を解放し接続を遮断します。また、必要に応じてLedgerをローカルに保存します。\n3.5 Merkle DAGオブジェクト #  分散ハッシュテーブル(DHT)やBitSwapプロトコルにより、IPFSはP2Pのシステム上で高効率で堅牢なデータブロックの保存や交換を実現することができます。IPFSではこれらの基盤上でMerkle DAG（有向非巡回グラフ）を構築します。これはオブジェクト間を暗号学的ハッシュ値によるリンクで結びつけたものであり、Gitのデータ構造を一般化したものです。Mekle Dagを採用することにより次のようなメリットが生まれます。\n コンテンツアドレッシング: 全てのコンテンツがそのコンテンツ自身のマルチハッシュのチェックサムをもとに同定されリンクされます。 耐改ざん性: 全てのコンテンツがそのチェックサムによりリンクされているため、コンテンツの改ざんを行う場合はそのコンテンツに向けたリンクも同時に変更するすることが必要になります。その結果耐改ざん性が増加します。 重複除去: 同一のコンテンツは同一オブジェクトとして扱われるため、同じコンテンツが別ブロックとして保存されることがありません。  IPFSのオブジェクトのフォーマットは下記のものです。\ntype IPFSLink struct { Name string // 本リンクの名前またはエイリアス Hash Multihash // リンク先オブジェクトの暗号学的ハッシュ値 Size int // リンク先オブジェクトのサイズ } type IPFSObject struct { links []IPFSLink // リンクのリスト data []byte // コンテンツ領域 } IPFSのMerkle DAGは非常に柔軟性の高いデータ保存方法です。(a)コンテンツアドレス形式であること、(b)上記のフォーマットに従っている、という２点のみが要求されます。IPFSではデータフィールドのフォーマットは上位のアプリケーションに完全に委ねられ、IPFS自身が理解できないカスタムフォーマットも利用可能です。IPFSオブジェクト内のリンクテーブルは下記の役割を果たします。\n オブジェクトが参照する全てのオブジェクトのリストを保持する。例えば  \u0026gt; ipfs ls /XLZ1625Jjn7SubMDgEyeaynFuR84ginqvzb XLYkgq61DYaQ8NhkcqyU7rLcnSa7dSHQ16x 189458 less XLHBNmRQ5sJJrdMPuu48pzeyTtRo39tNDR5 19441 script XLF4hwVHsVuZ78FZK6fozf8Jj9WEURMbCX4 5286 template \u0026lt;object multihash\u0026gt; \u0026lt;object size\u0026gt; \u0026lt;link name\u0026gt;   foo/bar/bazといったパスの解決を行う。オブジェクトが与えられた際、IPFSはオブジェクトのリンクを参照し、そのリンク先のオブジェクトのリンクを参照するというように辿りパス文字列をフェッチしていきます。\n  再帰的に参照オブジェクトを解決する。\n  \u0026gt; ipfs refs --recursive \\ /XLZ1625Jjn7SubMDgEyeaynFuR84ginqvzb XLLxhdgJcXzLbtsLRL1twCHA2NrURp4H38s XLYkgq61DYaQ8NhkcqyU7rLcnSa7dSHQ16x XLHBNmRQ5sJJrdMPuu48pzeyTtRo39tNDR5 XLWVQDqxo9Km9zLyquoC9gAP8CL1gWnHZ7z ... 3.5.1 パス #  IPFSのオブジェクトは従来のUNIXシステムやWebのパスと同様にパス（PATH）を指定してオブジェクトにアクセスすることが可能です。 IPFSでの絶対パスは以下のようなフォーマットで表されます。\n# フォーマット /ipfs/\u0026lt;hash-of-object\u0026gt;/\u0026lt;name-path-to-object\u0026gt; # 例 /ipfs/XLYkgq61DYaQ8NhkcqyU7rLcnSa7dSHQ16x/foo.txt 冒頭の/ipfsは既存のシステムにマウントする際のマウントポイント名であり、これにより既存のファイルシステムとの名前衝突を防ぎます（もちろんマウントポイント名は別の名前に設定することも可能です）。IPFSでは分散システムの中で多くのオブジェクトを保持するファイルシステムのアドレス一貫性を保つために、グローバルなルートディレクトリは持ちません。そのためパスの２階層目は必ずオブジェクトのハッシュ値が入ります。\n例えば/bar/bazのパスにあるオブジェクトbazは以下の３とおりのパス指定方法でアクセス可能です。\n/ipfs/\u0026lt;hash-of-foo\u0026gt;/bar/baz /ipfs/\u0026lt;hash-of-bar\u0026gt;/baz /ipfs/\u0026lt;hash-of-baz\u0026gt; 3.5.2 ローカルオブジェクト #  IPFSで管理されるオブジェクトの保存や取り出しを行うために、各IPFSクライアントはそれぞれローカルストレージを持つ必要があります。ほとんどの場合、このローカルストレージはクライアント上のディスクスペースの一部（ネイティブのファイルシステムに管理されたものや、leveldb［4］のようなKVSにより管理されたもの、IPFSにより直接管理されたもの含む）が利用されますが、揮発性の媒体（RAM）を利用するキャッシュ上に保持することも可能です。\nIPFS上で管理されるブロックは全て、どこかのノードのローカルストレージ上に保存されています。あるユーザーがそのブロックをリクエストした場合、IPFSの管理のもとでオブジェクトが探し出され、ダウンロードされ、そのユーザーのクライアントのローカルストレージ上に（少なくとも一時的には）保存されます。これは、以後そのブロックを取り出す場合に高速に取り出されるようするためです。\n（以降追記予定）\n3.7 IPNS: Naming and Mutable state #  ここまででIPFSはコンテンツアドレスでのDAGを構成することによるP2Pのブロック交換を実現しました。これにより不可変なオブジェクトの公開や取得が可能であり、またその改変も追うことが可能になります。しかし１つ足りない要素があります。それは変更可能な名前付けです。もしそれがなければコンテンツを新しく更新するとその度にIPFSのリンクを送る必要があります。そのため何らかコンテンツの更新を行っても同じパスで取得できるようにする仕組みが必要になります。 ここで、結局変更可能なデータである必要があるのに、なぜ不可変なMerkle DAGを利用したのか？それはオブジェクトを(a)そのハッシュ値で取り出すことを可能にし、(b)データの完全性を検証し、(c)他のデータにリンクし、(d)無制限にキャッシュが可能にできるからです。\nつまり一言でいうと、オブジェクトは恒久的なものであるということです。\n不可変なコンテンツアドレスのオブジェクトであるMerkle DAGと、Merkle DAGを指すポインターとしての名前付け機構が多くの優れた分散システムの両輪になっています。例えばGitのバージョンコントロールも不可変なオブジェクトと変更可能な参照により成り立ち、Unixの後継である分散型OSのPlan9[?]は不可変なファイルシステムであるFossilと可変なファイルシステムVentiの組合せであり、LBFS[?]も可変なインデックスと不可変なチャンクにより構成されていました。\n（以降追記予定）\n#  4. 今後 #  IPFSを構成する多くのアイデアは学術界での研究とオープンソースのコミュニティの中で数十年にわたって育まれたものになります。独自プロトコルであるBitSwapを除き、IPFSの主な貢献はそれらの数々のアイデアを統合したことです。IPFSは非中央集権なインターネットのインフラを提供するという野心的なプロジェクトであり、そのインフラ上で今後様々なアプリケーションが動作することが可能です。控えめに述べてもこのIPFSはグローバルに広がるバージョン管理可能なファイルシステムや名前空間として、そして次世代ファイル共有システムとして利用可能です。さらにはIPFSはWebの新たな地平を広げるものになるでしょう。それは、価値ある情報を提供者自身がホストすることなくそれを必要とする人自身がホストする、そして情報を受け取る側はホストの信用に関わらず改変や逸失の心配なく必要な情報が入手できるようになります。そのような永続的Webの世界に、IPFSは我々を導いてくれるでしょう。\n5. 謝辞 #  IPFSは多くの既存の素晴らしいアイデアやシステムの複合体であり、それら無くしてIPFSという壮大な目標を打ち立てることは出来なかったでしょう。また、David Dalrymple、Joe Zimmerman、そして Ali Yahyaに感謝します。 彼らはそれぞれ、一般マークルDAG（David, Joe）、ハッシュブロック(David), s/Kademliaでのシビル攻撃への防御（David, Ali）のアイデアについて長いディスカッションに付き合ってくれました。また、David Mazieresの素晴らしいアイデアに特別に感謝します。\n6. Reference TODO #  （訳者注：本節は原文でも空白になっています）\n7. Reference #  ［1］ I. Baumgart and S. Mies. S/kademlia: A practicable approach towards secure key-based routing. In Parallel and Distributed Systems, 2007 International Conference on, volume 2, pages 1–8. IEEE, 2007.\n[2] I. BitTorrent. Bittorrent and A¸ttorrent software surpass 150 million user milestone, Jan. 2012.\n[3] B. Cohen. Incentives build robustness in bittorrent. In Workshop on Economics of Peer-to-Peer systems, volume 6, pages 68–72, 2003.\n[4] J. Dean and S. Ghemawat. leveldb–a fast and lightweight key/value database library by google, 2011.\n[5] M. J. Freedman, E. Freudenthal, and D. Mazieres. Democratizing content publication with coral. In NSDI, volume 4, pages 18–18, 2004.\n[6] J. H. Howard, M. L. Kazar, S. G. Menees, D. A. Nichols, M. Satyanarayanan, R. N. Sidebotham, and M. J. West. Scale and performance in a distributed file system. ACM Transactions on Computer Systems (TOCS), 6(1):51–81, 1988.\n[7] J. Kubiatowicz, D. Bindel, Y. Chen, S. Czerwinski, P. Eaton, D. Geels, R. Gummadi, S. Rhea, H. Weatherspoon, W. Weimer, et al. Oceanstore: An architecture for global-scale persistent storage. ACM Sigplan Notices, 35(11):190–201, 2000.\n[8] D. Levin, K. LaCurts, N. Spring, and B. Bhattacharjee. Bittorrent is an auction: analyzing and improving bittorrent’s incentives. In ACM SIGCOMM Computer Communication Review, volume 38, pages 243–254. ACM, 2008.\n[9] A. J. Mashtizadeh, A. Bittau, Y. F. Huang, and D. Mazieres. Replication, history, and grafting in the ori file system. In Proceedings of the Twenty-Fourth ACM Symposium on Operating Systems Principles, pages 151–166. ACM, 2013.\n[10] P. Maymounkov and D. Mazieres. Kademlia: A peer-to-peer information system based on the xor metric. In Peer-to-Peer Systems, pages 53–65. Springer, 2002.\n[11] D. Mazieres and F. Kaashoek. Self-certifying file system. 2000.\n[12] D. Mazieres and M. F. Kaashoek. Escaping the evils of centralized control with self-certifying pathnames. In Proceedings of the 8th ACM SIGOPS European workshop on Support for composing distributed applications, pages 118–125. ACM, 1998.\n[13] J. Rosenberg and A. Keranen. Interactive connectivity establishment (ice): A protocol for network address translator (nat) traversal for offer/answer protocols. 2013.\n[14] S. Shalunov, G. Hazel, J. Iyengar, and M. Kuehlewind. Low extra delay background transport (ledbat). draft-ietf-ledbat-congestion-04. txt, 2010.\n[15] R. R. Stewart and Q. Xie. Stream control transmission protocol (SCTP): a reference guide. Addison-Wesley Longman Publishing Co., Inc., 2001.\n[16] L. Wang and J. Kangasharju. Measuring large-scale distributed systems: case of bittorrent mainline dht. In Peer-to-Peer Computing (P2P), 2013 IEEE Thirteenth International Conference on, pages 1–10. IEEE, 2013. ß\n  例えば、Linuxはディスクイメージの配布のためにBitTorrentを利用したり、Blizzard,Inc.はビデオゲームの配布のために利用したりしています。 \u0026#x21a9;\u0026#xfe0e;\n   "}]